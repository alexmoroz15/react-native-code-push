#include "pch.h"

//#include "CodePush.h"
#include "winrt/Windows.ApplicationModel.h"
#include "winrt/Windows.Storage.h"
#include "winrt/Windows.Storage.FileProperties.h"
#include "winrt/Windows.Foundation.h"

#include "CodePushUpdateUtils.h"

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::Storage;

using namespace CodePush;

IAsyncOperation<hstring> CodePushUpdateUtils::GetHashForBinaryContents(const StorageFile& binaryBundle)
{
    // Get the cached hash from local settings if it exists
    auto binaryModifiedDate{ co_await ModifiedDateStringOfFileAsync(binaryBundle) };
    auto localSettings{ ApplicationData::Current().LocalSettings() };
    auto binaryHashDictionaryData{ localSettings.Values().TryLookup(BinaryHashKey) };
    if (binaryHashDictionaryData != nullptr)
    {
        auto binaryHashDictionaryString{ unbox_value<hstring>(binaryHashDictionaryData) };
        JsonObject binaryHashDictionary;
        auto success{ JsonObject::TryParse(binaryHashDictionaryString, binaryHashDictionary) };
        if (success)
        {
            auto binaryHash{ binaryHashDictionary.GetNamedString(binaryModifiedDate, L"") };
            if (binaryHash.empty())
            {
                localSettings.Remove(BinaryHashKey);
            }
            else
            {
                co_return binaryHash;
            }
        }
    }

    JsonObject dictionary;
    JsonArray manifest;

    // If the app is using assets, then add
    // them to the generated content manifest.
    auto binaryFolder{ Windows::ApplicationModel::Package::Current().InstalledLocation() };
    auto bundleFolder{ (co_await binaryFolder.TryGetItemAsync(L"bundle")).try_as<StorageFolder>() };
    if (bundleFolder != nullptr)
    {
        auto assetsFolder{ (co_await bundleFolder.TryGetItemAsync(L"assets")).try_as<StorageFolder>() };
        if (assetsFolder != nullptr)
        {
            auto result{ AddContentsOfFolderToManifest(
                assetsFolder,
                L"CodePush/assets",
                manifest) };

            if (!result)
            {
                co_return L"";
            }
        }
    }

    AddFileToManifest(binaryBundle, manifest);
    
    auto binaryHash{ ComputeFinalHashFromManifest(manifest) };

    // Cache the hash in user preferences. This assumes that the modified date for the
    // JS bundle changes every time a new bundle is generated by the packager.
    binaryHashDictionary.Insert(binaryModifiedDate, binaryHash);
    localSettings.Values().Insert(BinaryHashKey, binaryHashDictionary);

    co_return binaryHash;
}

/*
+ (NSString*)getHashForBinaryContents:(NSURL*)binaryBundleUrl
error : (NSError**)error
{
    // Get the cached hash from user preferences if it exists.
    NSString* binaryModifiedDate = [self modifiedDateStringOfFileAtURL : binaryBundleUrl];
    NSUserDefaults* preferences = [NSUserDefaults standardUserDefaults];
    NSMutableDictionary* binaryHashDictionary = [preferences objectForKey : BinaryHashKey];
    NSString* binaryHash = nil;
    if (binaryHashDictionary != nil) {
        binaryHash = [binaryHashDictionary objectForKey : binaryModifiedDate];
        if (binaryHash == nil) {
            [preferences removeObjectForKey : BinaryHashKey] ;
            [preferences synchronize] ;
        }
        else {
            return binaryHash;
        }
    }

    binaryHashDictionary = [NSMutableDictionary dictionary];
    NSMutableArray* manifest = [NSMutableArray array];

    // If the app is using assets, then add
    // them to the generated content manifest.
    NSString* assetsPath = [CodePush bundleAssetsPath];
    if ([[NSFileManager defaultManager]fileExistsAtPath:assetsPath] ) {

        BOOL result = [self addContentsOfFolderToManifest : assetsPath
            pathPrefix : [NSString stringWithFormat : @"%@/%@", [self manifestFolderPrefix], @"assets"]
            manifest : manifest
            error : error];
        if (!result) {
            return nil;
        }
    }

    [self addFileToManifest : binaryBundleUrl manifest : manifest] ;
    [self addFileToManifest : [binaryBundleUrl URLByAppendingPathExtension : @"meta"] manifest : manifest] ;

    binaryHash = [self computeFinalHashFromManifest : manifest error : error];

    // Cache the hash in user preferences. This assumes that the modified date for the
    // JS bundle changes every time a new bundle is generated by the packager.
    [binaryHashDictionary setObject : binaryHash forKey : binaryModifiedDate];
    [preferences setObject : binaryHashDictionary forKey : BinaryHashKey] ;
    [preferences synchronize] ;
    return binaryHash;
}
*/

IAsyncOperation<hstring> CodePushUpdateUtils::ModifiedDateStringOfFileAsync(const StorageFile& file)
{
    auto basicProperties{ co_await file.GetBasicPropertiesAsync() };
    auto modifiedDate{ basicProperties.DateModified() };
    auto mtime{ clock::to_time_t(modifiedDate) };
    auto modifiedDateString{ to_hstring(mtime) };
	co_return modifiedDateString;
}